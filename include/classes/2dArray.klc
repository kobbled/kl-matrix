PROGRAM class_name
%NOBUSYLAMP
%COMMENT = '2d abstraction'
%NOLOCKGROUP
%UNINITVARS

%include namespace.m

-- declare type
%include define_type.m
t_arr2d(t_rows,t_columns,type_name,REAL)

--declare object member variables
VAR
  arr      : arry(type_name)

%include matrix.klt

ROUTINE init_(operation : INTEGER; value : REAL) FROM class_name

%include 2dArray.klh -- class.klh

%from math.klh %import srand, rand
%from strings.klh %import r_to_s, i_to_s
%include errors.klh
%include kunit.klh

ROUTINE constructor
  BEGIN
    init_ (OP_FULL, value)
  END constructor

ROUTINE desctructor
  VAR
    i,j : INTEGER
    row  : arrx(type_name)
    uninitr : REAL
  BEGIN
    FOR i=1 TO ARRAY_LEN(arr) DO
      FOR j=1 TO ARRAY_LEN(row) DO
        row[j] = uninitr
      ENDFOR
      arr[i] = row 
    ENDFOR
  END desctructor

ROUTINE full
  BEGIN
    init_ (OP_FULL, number)
  END full

ROUTINE zeros
  BEGIN
    init_ (OP_ZEROS,0)
  END zeros

ROUTINE ones
  BEGIN
    init_ (OP_ONES, 0)
  END ones

ROUTINE random
  BEGIN
    init_ (OP_RANDOM, 0)
  END random

-- private
ROUTINE init_
  VAR
    i, j : INTEGER
    tme  : INTEGER
    row  : arrx(type_name)
    rrand : REAL
  BEGIN
    FOR i=1 TO ARRAY_LEN(arr) DO
      FOR j=1 TO ARRAY_LEN(row) DO
        SELECT operation OF
          CASE (OP_ZEROS) :
            row[j] = 0.0
          CASE (OP_EYE) :
            IF (i=j) THEN
              row[j] = 1.0
            ELSE
              row[j] = 0.0
            ENDIF
          CASE (OP_FULL) :
            row[j] = value
          CASE (OP_RANDOM) :
            GET_TIME(tme)
            math__srand(tme*i*j)
            rrand = math__rand
            row[j] = rrand
          CASE (OP_ONES) :
            row[j] = 1.0
        ENDSELECT
      ENDFOR
      arr[i] = row
    ENDFOR
  END init_

-- testing routines
ROUTINE test_row
  VAR
    i : INTEGER
    ok : BOOLEAN
    assrtn_count : INTEGER
    error_msg : STRING[254]
    ent, status : INTEGER
  BEGIN
    ok = TRUE

    GET_VAR(ent, 'kunit', 'assrtn_count', assrtn_count, status)
    assrtn_count = assrtn_count + 1
    SET_VAR(ent, 'kunit', 'assrtn_count', assrtn_count, status)

    --actual test array should be equal to or greater than expected
    -- loop through arrays and check values
    FOR i = 1 TO ARRAY_LEN(actual) DO
      -- disregard comparision if item is outside of expected
      -- shape
      IF (i <= ARRAY_LEN(expected)) THEN
        -- handle uninitialized
        IF UNINIT(actual[i]) THEN
          error_msg = 'Expected ' + r_to_s(expected[i]) + ' but got UNINIT'
          RETURN(false)
        ENDIF

        IF expected[i] <> actual[i] THEN
          ok = FALSE
          GO TO skiploop
        ENDIF

      ENDIF
    ENDFOR

    skiploop::

    IF ok THEN
      RETURN(true)
    ELSE
      error_msg = 'Expected ' + r_to_s(expected[i]) + ' but got ' + r_to_s(actual[i]) + &
                  ', on index ' + i_to_s(i) + ' of array.'
      RETURN(false)
    ENDIF
  END test_row

ROUTINE testing
  VAR
    i,j : INTEGER
    row  : arrx(type_name)
    expect_row : arrx(type_name)
    b : BOOLEAN
    error_msg : STRING[254]
    ent, status : INTEGER
  BEGIN
    IF ARRAY_LEN(expected) > ARRAY_LEN(arr) THEN
      error_msg = 'rows are not the same size'
      SET_VAR(ent, 'kunit', 'error_msg', error_msg, status)
      CHK_STAT(status)
      RETURN(false)
    ENDIF

    FOR i=1 TO ARRAY_LEN(arr) DO
      row = arr[i]
      expect_row = expected[i]  

      b = test_row(expect_row, row)
      IF b = FALSE THEN
        error_msg = 'Row ' + i_to_s(i) + 'is not equal.'
        SET_VAR(ent, 'kunit', 'error_msg', error_msg, status)
        CHK_STAT(status)
        RETURN(false)
      ENDIF
    ENDFOR

    RETURN(true)
  END testing

BEGIN
END class_name